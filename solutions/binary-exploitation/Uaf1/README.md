# Uaf1

This exploit is an example of glibc's first-fit algorithm. When we allocate and free 1, the pointer still exists and still points to the same memory region. When we allocate 2, both 2 and 1 point to the same chunk of memory, therefore calling 1's function is the same as calling 2's function.

I've created a small program that illustrates this concept. You can compile and run first-fit.c yourself if you'd like, but the output of a sample run is below.

```
glibc uses a first-fit algorithm to choose where it gets memory from.
If a chunk is free and large enough, malloc will use this chunk.
This can be exploited in a use-after-free situation.

Allocating 8 bytes to A.
Allocating 8 bytes to B.

A: 0x565557557260
B: 0x565557557280

We can copy data to A.
A: 0x565557557260 -> A

Now let's free chunk A.

If we allocate less than or equal to 8 bytes, it well end up here: 0x565557557260.

Allocating 8 bytes to C.
C: 0x565557557260

If we check now, A and C point to the same piece of memory.
(0x565557557260 == 0x565557557260) == True

We can copy data to C.
C: 0x565557557260 -> C

If we reuse the first allocation, it now holds the data from the third allocation.
A: 0x565557557260 -> C
```

What is happening in our program is this:

```
Allocate size of struct uaf for 1; 1->func gets set
1: 0x100
1->func: 0x100 = exec1

Free 1; Memory still exists, is not erased
1: 0x100
1->func: 0x100 = exec1

Allocate size of struct uaf for 2; 2->func gets set
1: 0x100
1->func: 0x100 = exec2
2: 0x100
2->func: 0x100 = exec2

Call 1
1->func = exec2
system("cat flag.txt");
```
